name: build, test, release

on:
  push:
    branches: [ main ]
    paths:
      - 'projects/**'
  pull_request:
    types: [opened, synchronize, reopened]
    branches: [ main ]
    paths:
      - 'projects/**'
  workflow_dispatch:

concurrency:
  group: library-main-${{ github.ref }}
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/slurm-docker-cluster
  SLURM_VERSION: 25-05-3-1

jobs:
  validate-pr:
    name: Validate PR Title
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - uses: amannn/action-semantic-pull-request@v5
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          types: |
            feat
            fix
            docs
            style
            refactor
            perf
            test
            chore
            ci
            build
          requireScope: false
          disallowScopes: |
            release
          subjectPattern: ^(?![A-Z]).+$
          subjectPatternError: |
            The subject "{subject}" found in the pull request title "{title}"
            didn't match the configured pattern. Please ensure that the subject
            doesn't start with an uppercase character.
  validation:
    name: Validate library
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
      packages: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install uv
        uses: astral-sh/setup-uv@v6

      - uses: prefix-dev/setup-pixi@v0.9.1
        with:
            pixi-version: v0.56.0
            cache: true
            frozen: true
      - run: pixi run -e build --frozen lint

      - name: Run unit tests without real SLURM
        run: pixi run -e build --frozen testpixi

      - name: Log into registry ${{ env.REGISTRY }}
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Start SLURM Cluster using pre-built image
        env:
          IMAGE_TAG: ${{ env.SLURM_VERSION }}
        run: |
          docker compose \
            -f docker-compose.yml \
            -f docker-compose.ci.yml \
            up -d --wait --wait-timeout 120 || {
              echo "‚ö†Ô∏è Docker compose wait timed out or failed"
            }

          # Now, add a real check to fail the job if the container isn't healthy
          if ! docker ps | grep slurmctld | grep -q '(healthy)'; then
            echo "‚ùå slurmctld did not become healthy."
            docker logs slurmctld
            exit 1
          fi

      - name: Install SSH client on runner
        run: |
          sudo apt-get update
          sudo apt-get install -y openssh-client sshpass netcat-openbsd

      - name: üïµÔ∏è‚Äç‚ôÄÔ∏è Check Runner Environment
        run: |
          echo "### Runner OS Information"
          cat /etc/os-release
          echo
          echo "### OpenSSH Client Version"
          ssh -V
          echo
          echo "### OpenSSH Client Configuration"
          ssh -G localhost | grep -E '^(kexalgorithms|hostkeyalgorithms)'

      - name: Comprehensive SSH Verification (Runner -> Container)
        env:
          # Define credentials as ENV vars for clarity and reuse
          SSH_USER: submitter
          SSH_PASS: submitter
          SSH_HOST: localhost
          SSH_PORT: 2223
        run: |
          set -x # Print each command

          echo "---"
          echo "### STEP 1: Pre-flight Checks (Verifying Container State)"
          echo "---"

          echo "--> Effective sshd config (checking auth-related directives):"
          docker exec slurmctld sshd -T | egrep '^(passwordauthentication|pubkeyauthentication|usepam|permit.*login|allowusers|denyusers|allowgroups|denygroups|permitemptypasswords)' | sed 's/^/    /'

          echo "--> 'submitter' user status:"
          docker exec slurmctld id $SSH_USER
          docker exec slurmctld passwd -S $SSH_USER

          echo "--> 'submitter' user shell validity:"
          docker exec slurmctld getent passwd $SSH_USER
          docker exec slurmctld grep "$(getent passwd $SSH_USER | cut -d: -f7)" /etc/shells || echo "WARNING: User's shell may not be in /etc/shells"
          
          echo "--> Network listener INSIDE container:"
          docker exec slurmctld ss -ltn | grep ':22 '

          echo
          echo "---"
          echo "### STEP 2: Network Connectivity (Verifying Host State)"
          echo "---"
          echo "--> Basic TCP connection test:"
          nc -zv $SSH_HOST $SSH_PORT

          echo
          echo "---"
          echo "### STEP 3: Full SSH Connection Test (The Final Boss)"
          echo "---"
          # This is the most robust command.
          # -o PreferredAuthentications=password and -o PubkeyAuthentication=no force it to use only the method we care about.
          # -vvv provides maximum client-side debug information.
          if ! sshpass -p "$SSH_PASS" ssh -vvv \
            -o HostKeyAlgorithms=+ssh-rsa \
            -o PreferredAuthentications=password \
            -o PubkeyAuthentication=no \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            -p "$SSH_PORT" ${SSH_USER}@${SSH_HOST} 'echo "‚úÖ SSH connection successful"' 2> ssh_debug_output.log; then
          if ! sshpass -p "$SSH_PASS" ssh -vvv \
            -o PreferredAuthentications=password \
            -o PubkeyAuthentication=no \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            -p "$SSH_PORT" ${SSH_USER}@${SSH_HOST} 'echo "‚úÖ SSH connection successful"' 2> ssh_debug_output.log; then
            
            echo "======================================================================="
            echo "‚ùå ERROR: SSH connection failed. The most common cause is 'Permission denied'."
            echo "======================================================================="
            
            echo
            echo "### Client-side SSH debug output (-vvv):"
            echo "This log shows what the client sees. Look for 'Authentications that can continue: password' and then the failure."
            cat ssh_debug_output.log
            
            echo
            echo "### Server-side Authentication Log (MOST IMPORTANT LOG):"
            echo "This log shows why the server REJECTED the login. This is where the root cause is usually found."
            # Use '|| true' to prevent the step from failing if the log file doesn't exist yet.
            docker exec slurmctld cat /var/log/secure || true
            
            echo
            echo "### Full slurmctld container log (for context):"
            docker logs slurmctld

            exit 1
          fi

          echo "‚úÖ All SSH checks passed successfully."

      
      - name: debugging deployXX
        env:
          SLURM_EDGE_NODE_HOST: localhost
          SLURM_EDGE_NODE_PORT: 2223
          SLURM_EDGE_NODE_USER: submitter
          SLURM_EDGE_NODE_PASSWORD: submitter
          SLURM_DEPLOYMENT_BASE_PATH: /home/submitter/pipelines/deployments
        run: cd examples && pixi run deploy-prod-docker

      - name: Run integration tests against SLURM cluster
        env:
          SLURM_EDGE_NODE_HOST: localhost
          SLURM_EDGE_NODE_PORT: 2223
          SLURM_EDGE_NODE_USER: submitter
          SLURM_EDGE_NODE_PASSWORD: submitter
          SLURM_DEPLOYMENT_BASE_PATH: /home/submitter/pipelines/deployments
        run: pixi run -e build --frozen testpixi-integration

      - name: Stop SLURM Cluster and Clean Up
        if: always()
        run: |
          echo "Tearing down SLURM cluster..."
          docker compose logs
          docker compose down -v

      - run: pixi run -e build --frozen build-lib

  prerelease:
    name: Create pre-release
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read
      issues: read
      id-token: write
    needs: validation
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && !contains(github.event.head_commit.message, 'Automatically generated by python-semantic-release')
    environment: pre-release
    steps:
      - name: Generate GitHub App Token
        id: generate_token
        uses: tibdex/github-app-token@v2
        with:
          app_id: ${{ secrets.APP_ID }}
          private_key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ steps.generate_token.outputs.token }}

      - name: Install uv
        uses: astral-sh/setup-uv@v6

      - uses: prefix-dev/setup-pixi@v0.9.1
        with:
            pixi-version: v0.56.0
            cache: true
            frozen: true

      - run: pixi run -e build --frozen sync

      - name: Configure Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Create pre-release
        env:
          GH_TOKEN: ${{ steps.generate_token.outputs.token }}
        run: |
          set -e

          # Create pre-release version
          uv run semantic-release version --prerelease

          if ! git diff --staged --quiet; then
            git commit -m "chore: additional changes [skip ci]"
          fi
          
          # Push changes and tags
          git push origin main
          git push --tags
          
          # Create GitHub pre-release
          uv run semantic-release publish
      
      - name: Publish pre-release to PyPI (Trusted Publishing)
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          repository-url: https://test.pypi.org/legacy/
          skip-existing: true
          verbose: true

  release:
    name: Promote prerelease to full release
    runs-on: ubuntu-latest
    needs: validation
    permissions:
      contents: write       # Push commits, tags, and create releases
      pull-requests: read   # Read PR information for changelog generation
      issues: read          # Read issues for linking in releases
      packages: write       # Publish packages to GitHub Packages
      id-token: write
    if: github.event_name == 'workflow_dispatch'
    environment: release
    steps:
      - name: Generate GitHub App Token
        id: generate_token
        uses: tibdex/github-app-token@v2
        with:
          app_id: ${{ secrets.APP_ID }}
          private_key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ steps.generate_token.outputs.token }}

      - name: Validate and promote prerelease
        env:
          GH_TOKEN: ${{ steps.generate_token.outputs.token }}
        run: |
          set -e
          
          # Get current version from pyproject.toml
          CURRENT_VERSION=$(grep "version =" pyproject.toml | head -1 | cut -d'"' -f2)
          echo "üìã Current version: $CURRENT_VERSION"
          
          # Check if current version is a prerelease
          if echo "$CURRENT_VERSION" | grep -E "(rc|alpha|beta)" >/dev/null; then
            PRERELEASE_TAG="v$CURRENT_VERSION"
            echo "üîç Looking for prerelease tag: $PRERELEASE_TAG"
            
            # Check if the prerelease exists and is marked as prerelease
            if gh release view "$PRERELEASE_TAG" >/dev/null 2>&1; then
              IS_PRERELEASE=$(gh release view "$PRERELEASE_TAG" --json isPrerelease --jq '.isPrerelease')
              if [ "$IS_PRERELEASE" = "true" ]; then
                echo "‚úÖ Found valid prerelease: $PRERELEASE_TAG"
                echo "üöÄ Promoting to full release..."
              else
                echo "‚ùå Release $PRERELEASE_TAG exists but is not marked as prerelease"
                exit 1
              fi
            else
              echo "‚ùå Prerelease $PRERELEASE_TAG not found"
              echo "üí° Push changes to main branch to create a prerelease first"
              exit 1
            fi
          else
            echo "‚ùå Current version ($CURRENT_VERSION) is not a prerelease"
            echo "üí° Push changes to main to create a prerelease first"
            exit 1
          fi

      - name: Install uv
        uses: astral-sh/setup-uv@v6

      - uses: prefix-dev/setup-pixi@v0.9.1
        with:
            pixi-version: v0.56.0
            cache: true
            frozen: true

      - run: pixi run -e build --frozen sync

      - name: Configure Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Create release
        env:
          GH_TOKEN: ${{ steps.generate_token.outputs.token }}
        run: |
          set -e

          uv run semantic-release version

          if ! git diff --staged --quiet; then
            git commit -m "chore: additional changes [skip ci]"
          fi

          git push origin main
          git push --tags
          uv run semantic-release publish
          
      - name: Publish to PyPI (Trusted Publishing)
        if: github.event.inputs.release_type != 'prerelease'
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          skip-existing: true
          verbose: true
